---
draft: true
layout: post
title: Vim After 15 Years
description: XXX
image: /images/vim/vim3.png
---

It's been about four years since my earlier [Vim After 11 Years](/vim.html) post, which was well-received. I've been writing a lot of more code with Vim lately and I figured that it was about time for an update.

Since my previous post my core configuration hasn't changed much. However, the last few years have seen impressive growth in the Vim community. There have been an advent of new plugins, new Vim features (like asynchronous operations), and a new website to let us explore new plugins.

<figure>
<a href="/images/vim/vim3.png"><img src="/images/vim/vim3.png"/></a>
<figcaption>A recent Vim session</figcaption>
</figure>


### On Plugins

There always seems to be a backlash against using Vim with lots of plugins.  Part of this is understandable suspicion -- any system which allows users to add unordered extensions to patch itself without hesitation can easily become a mess. Just look at WordPress. Or, if you were around 20 years ago, try remembering extensions in Mac OS Classic, which were patches on top of patches. With these systems there's no formal way to declare dependencies and debugging incompatibilities becomes the norm.

Vim plugins aren't that bad. Debugging an interaction between plugins _X_ and _Y_ usually involves googling "vim X with Y." It's certainly not as bad as binary-searching your way through extension conflicts like [Conflict Catcher](https://tidbits.com/article/1496) used do on Mac OS Classic.

Further resistance towards plugins seems to a kind of purist animosity against straying away from some _core set_ of Vim functionality. However, if you use Vim, you're already in a subset of people who demand that editing text be fast and efficient, so this is like a group of savants arguing about which of them is more eccentric. If you use one of the movement plugins like [EasyMotion](https://vimawesome.com/plugin/easymotion) or [vim-sneak](https://vimawesome.com/plugin/vim-sneak) then probably agree that the tool you're using is more efficient than vanilla Vim, and those users think that using Vim is more efficient than the other text editors the larger set of people in the world are using. And so on.

Plugins have always been a part of Vim. With the recent improvements to Vim and VimL, such as [asynchronous process control](https://vimhelp.appspot.com/channel.txt.html) and [useful types](https://vimhelp.appspot.com/version7.txt.html#new-7), the plugin ecosystem is thriving. A new plugin site, [VimAwesome](https://vimawesome.com/), shows the most popular plugins as well, lets your browse and search, and has well-formatted documentation and install instructions using the myriad of plugin managers that now exist.

My opinion on plugins is thus: If a plugin provides useful functionality that I wish were built into Vim, it's worth installing. Otherwise, I try to keep the number of plugins at a minimum to avoid interaction problems and maintain crisp performance when starting Vim and viewing files. Thus, the plugins and configuration I list here are more about efficiency and getting stuff done instead of difference for the sake of difference.

### fzf

TextMate and Sublime Text taught us that the fastest way to go from firing neurons to viewing a file is by _fuzzy finding_, or rather, typing part of a filename or path to open a file, even if the characters aren't adjacent or you making a spelling error. This is such a useful navigation technique that it's become a standard feature on modern editors.

[Ctrl-P](https://vimawesome.com/plugin/ctrlp-vim-everything-has-changed) has been the reigning champ for years, but new tool, [fzf](https://github.com/junegunn/fzf), is much faster and thus more forgiving when trying to find one file or tag among thousands. Ctrl-P used to do OK on a 30,000-file codebase on my 2013-era MacBook Pro, but it really started to croak during a fuzzy search of our enormous tags file and was slow to the point of being unusable. fzf, however, shows no speed difference between files or tags -- it's blazingly fast either way.

XXX gif of using fzf

Getting started with fzf is pretty easy. Simply follow the [installation instructions](https://github.com/junegunn/fzf#installation) (basically `brew install fzf` on macOS with [Homebrew](https://brew.sh/)) and install the additional [fzf.vim](https://github.com/junegunn/fzf.vim) for badass lightspeed functionality.

fzf, which is an editor- and platform-independent utility, comes with a basic Vim plugin. However, its functionality is minimal, so a nice person wrote [fzf.vim](https://github.com/junegunn/fzf.vim) which provides all of the functionality you'd expect coming from Ctrl-P or a similar utility. fzf.vim has commands to search most everything from Vim, but the most useful commands are `:Files` and `:Buffers`, which I've bound to <kbd>,</kbd><kbd>t</kbd> and <kbd>;</kbd>: 

```vim
nmap ; :Buffers<CR>
nmap <Leader>t :Files<CR>
nmap <Leader>r :Tags<CR>
```

Binding <kbd>;</kbd> is important to me because I live and breathe in buffers -- I practically never use tabs, more on that later -- so it's important that I be able to switch focus to something I'm thinking of with as little friction as possible.

Don't forget the previous post where I [talked about](/vim.html#ctrl-e) binding <kbd>Ctrl-E</kbd> to swapping to the previously-opened buffer -- it's normally bound to <kbd>Ctrl-Shift-6</kbd>, but I found that hard to remember and type, so I rebound it to <kbd>Ctrl-E</kbd>. Also make sure you know about [<kbd>Ctrl-o</kbd>](https://vimhelp.appspot.com/motion.txt.html#CTRL-O), XXXXXX REMOVE

When using fzf, make sure to configure it to use `ag`, a `grep`/`ack` replacement called the [Silver Searcher](https://github.com/ggreer/the_silver_searcher), which will in turn respect your `.gitignore` and your `.agignore` files. You no longer need to keep a giant `wildignore` string in your `vimrc`! (Though if you still want to do that, consider the [RootIgnore](https://vimawesome.com/plugin/rootignore) plugin which configures `wildignore` according to your `.gitignore`.) The point is, `ag` is blisteringly fast, and FZF can make use of what you've already configured. Here's the snippet from my [.zshrc](https://github.com/statico/dotfiles/blob/340c01d0970bc2cd6a27284ddb87774131c00e5c/.zshrc#L812-L829):

```bash
if [ -e /usr/local/opt/fzf/shell/completion.zsh ]; then
  source /usr/local/opt/fzf/shell/key-bindings.zsh
  source /usr/local/opt/fzf/shell/completion.zsh
fi
if [ -e ~/.fzf ]; then
  _append_to_path ~/.fzf/bin
  source ~/.fzf/shell/key-bindings.zsh
  source ~/.fzf/shell/completion.zsh
fi
if _has fzf && _has ag; then
  export FZF_DEFAULT_COMMAND='ag --nocolor -g ""'
  export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
  export FZF_ALT_C_COMMAND="$FZF_DEFAULT_COMMAND"
  export FZF_DEFAULT_OPTS='
  --color fg:242,bg:236,hl:65,fg+:15,bg+:239,hl+:108
  --color info:108,prompt:109,spinner:108,pointer:168,marker:168
  '
fi
```

fzf works in the shell, too, and comes with bindings for Zsh, Bash, and the Fish shell. In Zsh, I can hit <kbd>Ctrl-t</kbd> to instantly fuzzy-find any file in the current directory. And since I've configured fzf to use `ag`, it'll ignore anything excluded by `.gitignore`. It's glorious.

I had originally written about the one big drawback to fzf being that it didn't work with MacVim. But the authors have recently [fixed this](https://github.com/junegunn/fzf.vim/issues/416#issuecomment-327982805) by using [the new built-in terminal in Vim 8](https://vimhelp.appspot.com/terminal.txt.html), and it works swimmingly.

#### An aside on fuzzy-finding

While FZF and Ctrl-P and other editors support fuzzy searching for pathnames, I'm really hoping that someone will implement a first-character search for Vim. For example, in IntelliJ, if you want to open the class `FooFactoryGeneratorBean` all you have to do is hit <kbd>Cmd-o</kbd> and type <kbd>F</kbd><kbd>F</kbd><kbd>G</kbd><kbd>B</kbd><kbd>Enter</kbd> to open it. This would be handy for searching tags as class names are often camel case regardless of language. Maybe it could treat characters before underscores as the first character so typing something like <kbd>f</kbd><kbd>b</kbd><kbd>b</kbd><kbd>q</kbd> would highlight a file like `foo_bar_baz_quux.js`. Just throwing that out there.

### Searching & the QuickFix window

If FZF is the new way to locate and act upon a _single_ path, `ag` is the new way to act upon _multiple_ paths. In other words, `ag` is the new `ack`, which was the new `grep`. The best way to use `ag` from within Vim seems to be [ack.vim](https://vimawesome.com/plugin/ack-vim), which is misleading since [ag.vim is deprecated](https://github.com/rking/ag.vim/issues/124#issuecomment-227038003), but ack.vim supports both `ack` and `ag`.

ack.vim gives you an `:Ack` command. It takes arguments in the same way as running `ag` from the command line, except that it opens the QuickFix window with the list of search results:

XXX image of using :Ag and QuickFix

Note that `:Ack` by default will jump to the first result in the QuickFix list. If you don't want this to happen, use `:Ack!`, or reverse the functionality of the two commands [per the docs](https://github.com/mileszs/ack.vim#i-dont-want-to-jump-to-the-first-result-automatically).

The most obvious way to use the QuickFix window is to moving the cursor there and hitting <kbd>Enter</kbd> to open a result. The `:cnext` and `:cprev` commands also move and up down the results, and I tried to find a cross-platform keybinding I liked for these for a while. Then I discovered [vim-unimpaired](https://vimawesome.com/plugin/unimpaired-vim), which adds useful bindings like <kbd>[</kbd><kbd>q</kbd> and <kbd>]</kbd><kbd>q</kbd> for `:cprev` and `:cnext`, which cycle to the previous and first QuickFix search result, respectively. vim-unimpaired actually has a lot more bindings for next/previous pairs, like navigating compiler/linter errors and toggling common options like line numbers.

Using the QuickFix window for search results so useful that I wrote a few bindings which search for the current word under the cursor:

```vim
nmap <M-k>    :Ack! "\b<cword>\b" <CR>
nmap <Esc>k   :Ack! "\b<cword>\b" <CR>
nmap <M-S-k>  :Ggrep! "\b<cword>\b" <CR>
nmap <Esc>K   :Ggrep! "\b<cword>\b" <CR>
```

`exhuberant-ctags` is only so-so at finding tags in Ruby and CoffeeScript, and sometimes you just need to search for that damned word that you're already staring at.

XXX gif of using Meta-k

Finally, after I'm done searching and navigating, I hit <kbd>\</kbd><kbd>x</kbd> (bound to `:cclose`) to close the QuickFix window. I'll probably want to navigate back to the original file I was looking at, and I usually hit <kbd>Ctrl-o</kbd> a few times, which [jumps backward in the jump list](https://vimhelp.appspot.com/motion.txt.html#CTRL-O) and is basically like hitting the Back button in a browser.  Other times I'll use <kbd>;</kbd> to bring up the buffer list. And now that I'm thinking about it, maybe I'll modify the binding set a [global mark](https://vimhelp.appspot.com/motion.txt.html#%270) in my <kbd>Meta-k</kbd> binding, like `o`, so that <kbd>'</kbd><kbd>O</kbd> will always take me back to where I started.

### Terminals, panes, and multiplexing

I mentioned before that I'm not a heavy gvim/MacVim user. I strongly prefer to work in a terminal, but there are some good reasons to use a standalone Vim application:

1. It's more responsive than Vim inside tmux
1. It's a better default application than TextEdit to open `.txt` files on macOS
1. It doesn't have a problem [clicking past the 220th column](https://stackoverflow.com/q/7000960/102704)
1. You're writing a long blog post with lots of spelling errors and for some damned reason Vim inside you terminal with your favorite font [won't show underlines](https://github.com/fabrizioschiavi/pragmatapro/issues/14)
1. Adherence to purity requires you to use the _true_ Solarized color scheme instead of the blasphemous scheme created when Solarized is [quantized to 256 colors](http://ethanschoonover.com/solarized/vim-colors-solarized#important-note-for-terminal-users)

A big reason to use Vim in a terminal is [tmux](https://github.com/tmux/tmux/wiki/FAQ). A lot of people use tmux to do remote development, but it's just wonderful for local development. As of now, tmux is now my fullscreen working environment, and Vim usually takes up one of the tmux panes. This lets use Vim while keeping a few other shells open -- usually a server and one or two other utility panes. Full-screen Vim is sometimes useful, and tmux lets you temporarily zoom a pane with <kbd>&lt;prefix&gt;</kbd><kbd>z</kbd>.

The killer feature is the ability to [send keys](http://minimul.com/increased-developer-productivity-with-tmux-part-5.html) to other tmux panes. That means I can set up a fancy REPL loop like an IDE -- I can edit in one pane and execute commands and see results in another pane, plus I can keep the server log visible in case there are any errors. For example, if I'm working on a REST, I can re-test the endpoint with `curl` and view the output with [jq](https://stedolan.github.io/jq/) using a few keystrokes:

XXX gif of testing aspen endpoint with tmux and curl+jq

The normal loop would be to make a change in Vim, hit <kbd>:</kbd><kbd>w</kbd><kbd>Enter</kbd> to save, the <kbd>Ctrl-t</kbd><kbd>h</kbd> to move to the left pane, then <kbd>Up</kbd><kbd>Enter</kbd> to repeat the command, and <kbd>Ctrl-t</kbd><kbd>l</kbd> to go back to Vim. But a simple keybinding in Vim can accomplish that much more quickly -- I used <kbd>\</kbd><kbd>r</kbd> as in "run" or "repeat":

```vim
nmap \r :!tmux send-keys -t 0:0.1 C-p C-j <CR><CR>
```

To explain, this executes the `tmux send-keys` command which tells it to send keys to session, window and pane (`0:0.1`) where I had run `curl` previously. It then sends <kbd>Ctrl-j</kbd>, which is equivalent to hitting <kbd>Up</kbd>, which pulls the previous command from history, and then <kbd>Enter</kbd> to execute it.

I've been using this for half a year and it's been a massive improvement to my productivity. However, it's worth mentioning that Vim 8 now supports [in-editor native terminals](https://vimhelp.appspot.com/terminal.txt.html), and they're pretty good. While various plugins have tried to integrate terminals into Vim before, usually with lackluster results, the new native terminals are fast, Unicode-aware, and 256 color-enabled, and there's a new `term_sendkeys()` function that lets you send keystrokes. This was only added to Vim a few months ago, so I need to experiment, but who knows -- I might end up using MacVim splits with `:terminal`s instead of tmux.

#### A note on terminals on macOS

I've been using [iTerm2](https://www.iterm2.com/) instead of macOS's default Terminal.app since forever. However, I recently noticed that typing in Vim inside iTerm2 felt a bit sluggish, especially Vim inside tmux. As a comparison I tried using `urxvt` inside XQuartz and it felt like lightning, so something was clearly adding latency. But I wasn't about to make `urxvt` my primary terminal on macOS because of the clipboard woes, focus issues, and lack of high-DPI support on XQuartz.

Coincidentally, a few days after noticing this, I read [an article](https://danluu.com/term-latency/) that demonstrated input latency between terminals and pointed out that Terminal.app is now significantly faster than iTerm2. I tried it for myself and confirmed that the keystroke latency was somewhere between urxvt and iTerm2, so I've switched to Terminal.app completely. I don't miss iTerm2's vertical splits as much since I'm using tmux. (Yes, I've tried iTerm2's tmux integration, but I never really saw how it was helpful.) Also, I was using a fancy [custom iTerm2 color theme](https://github.com/mbadolato/iTerm2-Color-Schemes) and was pleased to find a project which has [converted all the themes](https://github.com/lysyi3m/osx-terminal-themes) for Terminal.app.

Finally, I lied a little. I do miss one thing about iTerm2 vertical splits, and that's the very occasional case where I want a different font size in one pane than another. It's easy to do this with iTerm, or in fact _any_ editor other than those inside terminals.

### goyo + ProseMode + supertab + fzf for thesaurus?

Distraciton-free writing is pretty popular, and for good reason: it works. But I want to do my writing in Vim. So what's the solution?

A great plugin is [Goyo](XXX), which adds lots of padding to your buffer and hides all the cruft. It's aware of airline/powerline/lightline and whatever, so those get hidden too ([mostly](XXX)). I've combined that with a few other custom settings which I call **Prose Mode**:

XXX insert snippet of ProseMode

Basically, turn on Goyo, get rid of any funny source-code like indenting, and make autocompletion pull words from the thesaurus and dictionary to write even faster. It also changes the color scheme from my normal dark Molokai theme to the light version of Solarized. The latter is important because it becomes a mental reminder that I'm in "writing mode," and unlike in coding mode, I haven't given myself permission to mess around or get distracted, since my goal is to produce words and later edit them. Also, having (different highlight colors)[XXX] for misspellings in code and text feels like a useful stylistic choice.

### ale > syntastic

One of best modern additions to Vim is asynchronous functions. This was the most sorely needed feature in Vim and it is wonderful that Bram and the Vim maintainers finally implemented it.

The best manifestion of this new asynchronous behavior is a new lint checker, (ALE)[XXX], the Asynchronous Line EXXXXX. Now, when you write a file, the linter is run in the background. I've been writing a lot of Ruby for work, specifically in JRuby, and running the linter in JRuby can take a while to start up, so this is a welcomed addition.

XXX image of ruby linting with ALE

### lightline > airline/powerline

I used Powerline, which the newer "lighter-weight" Airline has replaced, for the last few years. After a while I decided that the information and widgets are more distracting than useful, so I switched to (lightline)[XXX] and spent a little extra effort to get my lightline status bar to look the way I wanted -- minimal information and distractions, and to show me the number of errors and warnings when things are wrong, and to show a solid ✓ when everything is peachy. I don't need to know the current file encoding or syntax.

XXX image of lightline

### fugitive + gitgutter + git-rhubarb + :Gbrowse + rootignore

If you're using Git, a few plugins are important.

[gitgutter](XXX) is a plugin that shows you the current git change status on a line-wise basis, like most editors do nowadays. I modified the defaults, which use distracting `+` and `-` characters, to simply show me a colored dot (`·`) for each line change, which I think looks a lot cleaner.

[vim-fugitive](XXX) is currently the single most popular Git plugin for Vim and has lots of capability. I rarely use anything other than `:Gblame`, but it's got a lot of other nice things you'd expect from in-editor Git tools.

[git-rhubarb](XXX) provides support for GitHub, and most importantly, a `:Gbrowse` command which opens the current file with optional line selection in the browser on GitHub. This is extremely useful because GitHub now inlines links to commits and line numbers are snippets from within issues and pull requests. So all you have to is select a few lines with <kbd>Shift-v</kbd>, run `:Gbrowse`, copy the URL that opens, and paste it into a GitHub comment to get something like this:

XXX pic of inline code snippet in GitHub issue.

[rootignore](XXX) deserves a metion because it populates your `wildignore` setting with the contents of `.gitignore`, among other things. This is useful for the many things that use the `wildignore` setting, such as [NERDTree](XXX) file listings, Ctrl-P, and Vim itself when choosing what files to edit.

### buffers not tabs - bufkill, eunuch

I'm a staunch user of buffers, and I've never found the use of tabs. All tabs do is create an additional way of hiding context from visibility and it requires you to memorize another keybinding or command to get at them. If you're using tmux, it's a lot easier to open Vim in another pane. And if you're making good use of buffers, it's easy to get at the file you're thinking of with a few keystrokes using FZF as described above.

If you don't really use buffers, it's easy to understand: Once you start Vim, any file you open or create becomes a named buffer. You can view them using the `:buffers` command, and navigate to one of them using `:buf <name>`, where `<name>` is any part of the filename of the buffer. They also have numbers, which `:buffers` shows you, and you can refer to them that way. If you start Vim from the command line with multiple files as command line arguments, each file will already be open in a buffer for easy access. If you've installed [vim-unimpaired](XXX), you can use the <kbd>[</kbd><kbd>b</kbd> and <kbd>]</kbd><kbd>b</kbd> keybindings to navigate between them easily. As I mentioend above, I've sped this process up considerably by binding the <kbd>;</kbd> key to the FZF `:Buffers` command so that a single keystroke brings up a buffer list with fuzzy-finding. A few more keystrokes, then <kbd>Enter</kbd>, and I'm there.

Sometimes you add a buffer and want to get rid of it. Maybe you opened a similarly named test file instead of the main class, or maybe you hit `:e foo` and then <kbd>Enter</kbd> too quickly and created a new bfufer iwith a file that doesn't really exist. In this case, the `:bd` command (short for `:bdelete` or _buffer delete_) can be used to delete the buffer and remove it from the list. 

However, `:bd` will close the Vim split if you use it on the currenttly visible buffer, so a great plugin is [bufkill](XXX), which lets you kill buffers and keep the split open, reverting to the previously edited buffer in its place. This is so useful that I bound it to <kbd>Meta-w</kbd> so I have a single-keystroke way of deleting a buffer from my list of open buffers.

Speaking of buffer management, sometimes you need to do something external to a file, such as rename it or chmod it, but the open buffer in Vim gets out of sync. NERDTree helps with this by letting you navigate to the current open file using `:CD` (XXXX true?), highlighting it, hitting <kbd>m</kbd> to modify it, and then choosing an action like rename. However, a much more convenitnet plugin is [vim-eunuch](XXX), which gives you a host of commands to modify files but keep the buffers in sync: `:Chmod` chmods the current file, `:Rename` renames the file in its parent direcotry, `:Move` moves it to a new path completely. There are a [few more](XXX) commands but those are the most useful to me.

### polyglot - vim-markdown

A plugin that a [friend](XXX) turned me onto is [vim-polyglot](XXX), which singlehandedly replaces over 150 (XXX verify) different language plugins by installing them as a single plugin. This is a nice convenience, especially since the author of the plugin keeps its dependencies up to date. The plugins chosen when there are multipel to choose from, such as the case with JavaScript, seems to be the most popular and widely-accepted choice.

The only problem with vim-polyglot so far is a problem inherant to Vim's loose plugin architecture: ordering. I already found [one bad interaction](XXX) when trying to use the [vim-css-jsx](XXX) plugin, and my solution was to [reanme the plugin when installing it](XXX) so that it loads before vim-polyglot. I'm not proud of that solution, but so far it appears to be the only plugin ordering problem I've encountered.

### other plugins: commentary, endwise+closetag, fugtivie, repeat, sleuth

Commenting out code is a common activity, so it makes sense to use a plugin that is smart enough to comment lines or blocsk of code in multipel lanaguges. Usually you can get away with something like `:s/^/#` if you're in a language that uses hashes to comment out lines, but if you use the [vim-commentary](XXX) plugin, commenting is a simple <kbd>g</kbd><kbd>c</kbd> away, regardless of language. The same key combination also uncomments the selected lines if they're already commented. Of course, if some lines are commented and others aren't, it doesn't work the smartes, but that's hard logic to figure out.

ANother common activity is inserting end-block statements, like `end` if you're writing Ruby, or `fi` if you're writing shell, or `endfunction` if you're hacking on VimL. I've been mostly content by doing this by hand for over a decade, but the [endwise](XXX) plugin has really turned me on to the auto-insertion of these keywords. I already use the bastardly-essential [closetag](XXX) plugin to complete HTML and XML tags in any kind of file, so using endwise felt like a natuarl extenstion.

Many of us already use [vim-surround](XXX), which adds keybindings to add, remove, and change the surrounding characters of any bit of text, such as changing single quotes to double quotes or brackets to parentheses. Unfortunately, by default, the <kbd>.</kbd> key doesn't repeate these substitiutions, but the [repeat](XXX) plugin makes that work. Need to change quotes in _multiple_ strings? Do the <kbd>c</kbd><kbd>S</kbd><kbd>'</kbd><kbd>"</kbd> or similar combination once, then use the familiar <kbd>.</kbd> key to repeate the substitiution anywhere else.

In the original post I mentioned my [tab and space fixing macros](XXX) which are handy when dealing with codebases that aren't your own and use differnent settings for tabs and spaces. What's really useful, however, is the [vim-sleuth](XXX) plugin, which automatically scans files when they're opened and tries to figure out the indentation settings used. It works 90% of the time, and pretyt much removes the most uses of the macros I set up. I especially don't need to insert [Vim modelines](XXX) at the tops of files anymore.

### about editors - vs code / intellij / vim + incsearch from emacs

It's worth talking about editors for a moment. Yes, I'm fully aware of the holy war nature of these arguments, but I feel that this decade we can at least agree on the right tool for the right job. We've never had such a swath of tools to get anything done -- editors, languages, frameworks, serializaztion formats -- so I think we're all a bit better about respecting other choices. (Is he kidding? That's an excercise for the reader.)

I've encountered a few handfuls of people over the years that are getting into programming, and inveitably they ask which text editor to use for writing code. My response is easy and immeidate: Just use Sublime Text. It's a great editor, it's got a great plugin community with up-to-date syntax highlighting, and it works well on macOS, Windows, and Linux.

XXX pic of sublime text

Why is Sublime Text my first recommendation? Because learning Vim just adds extra overhead. If you're learning programming, a pedantic and brain-abraisve trade by default, learning the strange and seemiingly-arcane cvombination _just to enter and edit text on the screen_ can be maddening. Sublime Text words like word processors for normal humans and is instantly useable.

I have a few more caveates, however. For Java, the leader is probably IntelliJ IDEA. Ten years ago it required a commercial license, but the free [Community Edition](XXX) is now available to anybody, and has the features a modern Java or Kotlin developer wants and needs, like Maven build support and Git integration. The real reasons to use IntelliJ with these languages is its amazing refactoring support, intelligent completion, [function signature annotations](XXX), smart indexing and searching (yes, way better than ctags), and its interactive debugger. In fact, when writing Ruby with JRuby, if I need to debug anything more than a simple `puts` will give me, I fire up IntelliJ and use the debugger. Besides, the free [IdeaVIM](XXX) plugin gives you Vim keybindings if you want them, and it works reasonably well.

XXX pic of intelli-J

Finally, [NeoVim](XXX) has caught my attention, but I'm far from making the switch. The big thing it advertised when it first came out was asynchronous function support, which has since been added in Vim 8. Other than that, I don't see a real advantage of using it over vanilla Vim, but I'm interested in seeing where it goes and who ends up using it.

### concluseion

I hope this has been useful to you. Vim has been a major part of my prgoramming life, and it's probably responsible for the successful partrs of my career -- maybe even the unsuccessful parts where I wasted too much time.

I'm well past 30 years old now, which makes me about 150 in programmer years, and my focus now is on _getting stuff done_ instead of mucking about with my tools. But Vim is one of those tools where doing a little work and a little research, such as browsing [VimAwesome.com](XXX) or reading a few lines in a help page, can dramatically improve your effectiveness. In the most eggregious cases, when your brain needs a break from programming, it's usually pretty easy to think, "Hey, what's one thing that's really bugged me in Vim while I was doing X," and fine a solution for it quicikly.

I hope that this has been useful. Also check out my earlier posts, [Vim After 11 Years](XXX) and [Everything I Missed in _Vim After 11 Yeras_](XXX). Let me know what you think in the comments.

XXXXXXXXXXXXX TODO:

- fzf works in macvim!
- i think rootignore sucks
