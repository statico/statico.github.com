---
layout: post
title: Vim After 11 Years
draft: true
---

## TL;DR

* Use Vim in a terminal, background (<kbd>Ctrl-Z</kbd>) often.
* Get a terminal that supports Unicode and 256 colors -- [iTerm][iterm] on Mac OS X, probably Gnome Terminal or rxvt-unicode on Linux.
* [Powerline][powerline], [Ctrl-P][ctrlp], [NERD Tree][nerdtree], [Syntastic][syntastic], [closetag.vim][closetag]
* Also, a few things I often show others.

## Introduction

Sometime in 2001, shortly after starting college, I got my first real Unix shell on Northeastern CCS's computing infrastructure.  This was a revelation because, prior to that, development meant uploading files to servers via FTP.  Even when I was 10 and writing simple C programs I would edit them locally with BBEdit and upload them to my dad's web host where I knew the `cc` command would compile them.  Shortly after starting college I realized that this method wasn't efficient and I decided I needed to learn to edit files on the remote host. `pico` didn't have syntax highlighting, but that thing called `vim` did, so I ran it, read the onscreen instructions and started messing the tutorial.

The following eleven years involved a lot of mucking about.  I've had a few full-time jobs, used many different operating systems, performed lots of debugging with many different tools, co-authored a book, got a degree, compiled Linux kernels, built infrastructure, screamed at `X11.conf`, and made things run on Solaris that really, really didn't want to. I've settled on using Mac OS X as a development environment because everything Just Works and I never have to think about `modprobe` or `ifconfig` again.

I've had plenty of opportunities to use Eclipse, IntelliJ IDEA, Emacs, TextMate, BBEdit, Flash Builder, 
XXX

## Customizing Vim: A Preamble

[Pathogen][pathogen] is a neat little plugin that lets you keep plugins in subdirectories of `.vim/bundle/` instead of merging everything into one big `.vim/` tree. It's easy to install and makes plugin testing a breeze.

It's also useful to keep your `.vim/` directory in version control. I'll occasionally make commits for changes in my `.vimrc`, but it's super useful to be able to test a plugin or setting and, if I don't like it, put everything back the way used to be with a `git revert`.

I use an [update.sh script][update.sh] I wrote to install plugins as well as keep everything up date. Keeping Vim plugins up to date can be useful. I've found that Vim plugins are often updated to fix bugs but not change functionality significantly.

Regarding mappings, I use the backslash key as my utility prefix since backslash isn't bound to anything by default. For example, <kbd>\o</kbd> toggles paste mode and <kbd>\l</kbd> toggles line numbers: 

    :nmap \l :setlocal number!<CR>
    :nmap \o :set paste!<CR>

## Rudimentary Essentials

<kbd>Esc</kbd> is used to return to Normal mode, but on most keyboards the <kbd>Esc</kbd> key is pretty far from the home row. <kbd>Ctrl-\[</kbd> produces the same keycode but involves two hands. Both might have problems on latent terminals which support <kbd>Esc</kbd> as an alternative to <kbd>Meta</kbd>. <kbd>Ctrl-C</kbd> is the answer — it's easy to type and instant. The only caveat is that you still need to use <kbd>Esc</kbd> for operations in visual block mode.

Moving around text is part of what makes using Vim feel so efficient. The one single thing I could never stand about Vim's default movements, however, is how <kbd>j</kbd> and <kbd>k</kbd> move around wrapped lines. By default they move you one line down and up, respectively, but on a _linewise_ basis. If I hit <kbd>j</kbd> I expect the cursor to move down a single row on the screen, just like every other text editing area in the world. The following does just that:

    :nmap j gj
    :nmap k gk

It might be amusing to refer to Vim's command line as such when by default it behaves very unlike a modern command line. If you're used to Emacs-style movement keys on your Bash or Zsh command line you might want to make Vim act the same way:

    :cnoremap <C-a>  <Home>
    :cnoremap <C-b>  <Left>
    :cnoremap <C-f>  <Right>
    :cnoremap <C-d>  <Delete>
    :cnoremap <M-b>  <S-Left>
    :cnoremap <M-f>  <S-Right>
    :cnoremap <M-d>  <S-right><Delete>
    :cnoremap <Esc>b <S-Left>
    :cnoremap <Esc>f <S-Right>
    :cnoremap <Esc>d <S-right><Delete>
    :cnoremap <C-g>  <C-c>

Another thing we do often is search, so it makes sense to have some sane defaults. The `incsearch` option highlights as you type an expression (a.k.a. "Emacs style"), and `ignorecase` plus `smartcase` make searches case-insensitive _except_ when you include upper-case characters (so `/foo` matches `FOO` and `fOo`, but `/FOO` only matches the former). `hlsearch` is a useful option which highlights the current search, but the highlight can become annoying so it makes sense to have a key to clear the highlight when you no longer need it:

    :set incsearch
    :set ignorecase
    :set smartcase
    :set hlsearch
    :nmap \q :nohlsearch<CR>

## Vim, the Terminal, Buffers, and You.

There are two forms: Vim in the console and the native GVim application. The advantages of GVim are better OS integration for dialogs, printing and the clipboard as well as prettier theme colors.

It was decided early in its development that [Vim isn't designed to replace a terminal][vimnoterm], so Vim is and forever will be bad at emulating terminals. Trying to use `:shell` is a path to madness. One plugin, [Conque][conque], comes close to terminal support in Vim, but it caused Vim to hang and its integration felt clunky. Thus, if you do a lot of work with from the command line while you edit, the best way to run Vim is from the command line.

One of Vim's strengths is that it starts lightning fast, so starting Vim from the terminal is trivial. With a modern, 256-color terminal like [iTerm][iterm] or Gnome Terminal, it will even look like GVim. But the best part is that you can drop into the command line at any time with <kbd>Ctrl-Z</kbd>, which suspends Vim, and your working directory is where you left off.

If you have trouble remembering which terminal has Vim suspended, try [adding the number of background jobs to your shell prompt][bashstoppedjobs]. If you have many Vims in the background, however, you should start using buffers instead.

Vim has the powerful ability to keep multiple files open in the background, and there are many ways to navigate between them. This is useful for performing work on a project or for editing multiple files as part of an operation.

For example, say your current working directory is a Django project and you want to edit the shopping cart request handler, so you run `vim cart/views.py`. Once Vim is open you realize you need to change a setting so you type `:e settings.py`, which opens up the file `settings.py` in the current window. You can get back to the other file by running `:b views` (`:b` is short for `:buffer`), which performs a substring match across all buffers, or use `:b#`, which opens the previously viewed buffer. Buffers become more powerful once you start using CtrlP, which I'll get to below.

A lot of times you'll want to do some work somewhere other than the file you're editing and return afterward, in which case `:b#` is a godsend. (Or `:e#`, I'm not sure if there's a difference.) It's so useful that it deserves a more natural keybinding, like <kbd>Ctrl-E</kbd>. (The default binding is <kbd>Ctrl-Shift-6</kbd>, which you'll never remember, and nobody knows what <kbd>Ctrl-E</kbd> does anyway.)

    :nmap <C-e> :e#<CR>

Vim automatically creates a buffer for each file on the command line. This is useful from the command line, such as with `vim *.js`, or combined with grep/[ack][ack]: ``vim `grep -l foo *.js` ``. I use this pattern so often that I bound two keys to cycle between all open buffers:

    :nmap <C-n> :bnext<CR>
    :nmap <C-p> :bprev<CR>

## Yes, My Editor Does That

Vim has error highlighting through the plugin [Syntastic][syntastic], which uses external compilers and linters to show errors inline with your code. This is absolutely essential.

XXXX pic of syntastic

TextMate raised the bar when it introduced it's "Go To File..." command which lets you quickly jump to any file using a fuzzy text search. The best Vim equivalent is [Ctrl-P][ctrlp], which not only has a fuzzy file search, but a fuzzy buffer search as well:

XXXX pic of ctrlp

If you use Vim buffers, Ctrl-P's ability to quickly go to the buffer you want is life-changing. It's so useful that I've bound it to <kbd>;</kbd> (and nobody remembers what <kbd>;</kbd> does anyway). Ctrl-P's file search combined with buffer search is magnificent – use the file search to open files related to the task at hand, then use buffer search to flip in between them.

    :nmap ; :CtrlPBuffer<CR>

It's worth showing a few settings for Ctrl-P. The following are the settings I use which map it to <kbd>,t</kbd>, put it at the top of the screen, hide unnecessary files from the search results, and a few more things. Run `:help ctrlp-options` to read more about them.

    :let g:ctrlp_map = '<Leader>t'
    :let g:ctrlp_match_window_bottom = 0
    :let g:ctrlp_match_window_reversed = 0
    :let g:ctrlp_custom_ignore = '\v\~$|\.(o|swp|pyc|wav|mp3|ogg|blend)$|(^|[/\\])\.(hg|git|bzr)($|[/\\])|__init__\.py'
    :let g:ctrlp_working_path_mode = 0
    :let g:ctrlp_dotfiles = 0
    :let g:ctrlp_switch_buffer = 0

A collapsible directory tree is a great tool to explore a project structure when you don't know what you're looking for or to help keep the project's organization in your head. The best file browser plugin is [NERD Tree][nerdtree], which has easy-to-remember keyboard navigation (hit <kbd>?</kbd> in the window for help), mouse support, and uses little Unicode arrows next to folders.

(XXXX pic of nerd tree)

It's also useful to have a key which toggles the visibility of the tree:

    :nmap \e :NERDTreeToggle<CR>

Finally, everybody has a color scheme they're comfortable with. Modern terminals support 256 colors, but sometimes you need to kick Vim to recognize this:

    if $TERM == "xterm-256color" || $TERM == "screen-256color" || $COLORTERM == "gnome-terminal"
      set t_Co=256
    fi

You can't, unfortunately, start using any GVim theme immediately, though there's [a plugin][csapprox] that tries to make that happen. There exists a plugin called [vim-colorschemes][vim-colorschemes] which has bundled hundreds of themes with 256-color support, such as `twilight256` and `wombat256`. It also includes the popular Zenburn theme, but its copy isn't as good as the [independently-maintained zenburn.vim][zenburn]. If you want to see what all of the themes look like, check out [vimcolorscheme][vimcolorscheme] page which contains samples of each theme.

Finally, in terms of visuals, Vim's default status line is pretty lacking. A popular plugin is [Powerline][powerline], which displays lots of helpful things in the status bar including your current git branch. It also uses colors to cue you into the current mode as well as when `paste` is enabled:

XXXX - pic of powerline

(Note: As of this writing it seems that the authors of Powerline decided to port the plugin to Python, which unfortunately requires a Vim build with Python support and complicates its installation. The [pure vimscript version][powerline] is still availabe.)

## Dealing With Other People's Code

If everyone could write code like you, wouldn't the world be a great place? Unfortunately, there are still some jerks who use or don't use tabs, or maybe they indent with four spaces instead of two, or vice versa, or whatever it is that those jerks do. You still need to read their code and it helps to be able to quickly switch between popular (and unpopular) tab modes:

    :nmap \t :set expandtab tabstop=4 shiftwidth=4 softtabstop=4<CR>
    :nmap \T :set expandtab tabstop=8 shiftwidth=8 softtabstop=4<CR>
    :nmap \M :set noexpandtab tabstop=8 softtabstop=4 shiftwidth=4<CR>
    :nmap \m :set expandtab tabstop=2 shiftwidth=2 softtabstop=2<CR>

Those some authors might wrap or not wrap lines at 80 or 100 columns or whatever it is you like, so being able to quickly toggle wrap mode helps:

    :nmap \w :setlocal wrap!<CR>:setlocal wrap?<CR>

## Things Which Friends Found Interesting

All text cut and copy operations are saved into registers. If you have cut text and then cut something else, you haven't lost the first cut -- just type `:reg` (short for `:registers`) to see all of the registers. You can then type the name of the register and then `p`, such as <kbd>"3p</kbd>, to paste whatever you cut three or four operations prior.

It's a good habit to use registers for longer-term copies and pastes. If there's anything I want to save "in the clipboard" for a while, I cut or copy it to register `a` , such as with <kbd>"ay</kbd> (copy) or <kbd>"ad</kbd> (cut). That way, no matter how many operations later, I'm still able to paste what I wanted with <kbd>"ap</kbd>. 

Note that macros are saved to registers, too. (You know about macros, right?) If you record a macro into register `a` (using the <kbd>q</kbd> key to start and stop it), you can type `:reg` to see the contents of the macro.

XXXX - pic of registers

Another interesting, seldom-used feature is visual block selection mode. If you type <kbd>Ctrl-v</kbd> in normal mode instead of <kbd>Shift-v</kbd>, your selection will be a rectangular block instead of a linewise selection. You can then perform cut and insert operations with <kbd>c</kbd> or <kbd>i</kbd> and, as long as you finis the operation with <kbd>Esc</kbd> and not <kbd>Ctrl-c</kbd>, the operation will be repeated for every line in the block.

XXXX pic of visual block selection

Finally, Vim has built in tag support for motions. This means that, if you're used to operating on paragraphs using, say, <kbd>dap</kbd> (delete a paragraph) or <kbd>ci(</kbd> (delete and insert in parentheses), you can do the same with tags: <kbd>dat</kbd> deletes the tag that the cursor is in, and <kbd>dit</kbd> deletes only the contents of the tag.

# Conclusion

I hope this has been useful. 

## Appendix A: Things I Miss From Emacs

* **CSS color highlighting everywhere.** Emacs has [a useful mode][emacscss] which highlights hexidecimal colors in CSS and SASS with the color represented by the text. It's smart enough to display light text when the color is dark and vice-versa.
* **Multiple font sizes.** It's truly wonderful to have large text appear larger while editing. There's something to be said for WYSIWYG mode when editing HTML or Markdown.

I thought this list would be a lot longer, but it turns out that I've replaced all most all of the features I miss from Emacs. Search and replace is decent, I found [a `:Rename` command] which renames the buffer _and_ the file simultaneously, Syntastic is as good as flymake, and the Zenburn theme makes everything look the same. I still have equal and minimal inclination to more Emacs Lisp and vimscript.

## Appendix B: Things I Miss From Intelli-J, Eclipse, and Flash Builder

* **Refactoring.** The downside of working with dynamic languages such as JavaScript make writing refactoring engines hard, but even non-language-specific editors like Sublime Text make it easy to rename a variable everywhere within a function. The <kbd>n</kbd>-then-<kbd>.</kbd>-repeat pattern gets old. For Python, there's a thing called [ropevim][ropevim] which adds some refactoring commands, but I've found it to be clunky and reliable.
* **Smart completion.** Same arguments as above, including the bits about ropevim.

  [bashstoppedjobs]: http://tldp.yolinux.com/HOWTO/Bash-Prompt-HOWTO.html#AEN733
  [csapprox]: http://www.vim.org/scripts/script.php?script_id=2390
  [vimcolorscheme]: http://vimcolorschemetest.googlecode.com/svn/html/index-html.html
  [emacscss]: http://www.emacswiki.org/emacs/CascadingStyleSheetMode
