---
layout: post
title: Vim After 11 Years
draft: true
---

## TL;DR

* Use Vim in a terminal, background (<kbd>Ctrl-Z</kbd>) often.
* Get a terminal that supports Unicode and 256 colors -- [iTerm][iterm] on Mac OS X, probably Gnome Terminal or rxvt-unicode on Linux.
* [Powerline][powerline], [Ctrl-P][ctrlp], [NERD Tree][nerdtree], [Syntastic][syntastic], [closetag.vim][closetag]
* Also, a few things I often show others.

## Introduction

Sometime in 2001, shortly after starting college, I got my first real Unix shell on Northeastern CCS's computing infrastructure.  This was a revelation because, prior to that, development meant uploading files to servers via FTP.  Even when I was 10 and writing simple C programs I would edit them locally with BBEdit and upload them to my dad's web host where I knew the `cc` command would compile them.  Shortly after starting college I realized that this method wasn't efficient and I decided I needed to learn to edit files on the remote host. `pico` didn't have syntax highlighting, but that thing called `vim` did, so I ran it, read the onscreen instructions and started messing the tutorial.

The following eleven years involved a lot of mucking about.  I've had a few full-time jobs, used many different operating systems, performed lots of debugging with many different tools, co-authored a book, got a degree, compiled Linux kernels, built infrastructure, screamed at `X11.conf`, and made things run on Solaris that really, really didn't want to. I've settled on using Mac OS X as a development environment because everything Just Works and I never have to think about `modprobe` or `ifconfig` again.

I've had plenty of opportunities to use Eclipse, IntelliJ IDEA, Emacs, TextMate, BBEdit, Flash Builder, 
XXX

## Customizing Vim: A Preamble

[Pathogen][pathogen] is a neat little plugin that lets you keep plugins in subdirectories of `.vim/bundle/` instead of merging everything into one big `.vim/` tree. It's easy to install and makes plugin testing a breeze.

It's also useful to keep your `.vim/` directory in version control. I'll occasionally make commits for changes in my `.vimrc`, but it's super useful to be able to test a plugin or setting and, if I don't like it, put everything back the way used to be with a `git revert`.

I use an [update.sh script][update.sh] I wrote to install plugins as well as keep everything up date. Keeping Vim plugins up to date can be useful. I've found that Vim plugins are often updated to fix bugs but not change functionality significantly.

Regarding mappings, I use the backslash key as my utility prefix since backslash isn't bound to anything by default. For example, <kbd>\o</kbd> toggles paste mode and <kbd>\l</kbd> toggles line numbers: 

    :nmap \l :setlocal number!<CR>
    :nmap \o :set paste!<CR>

## Rudimentary Essentials

<kbd>Esc</kbd> is used to return to Normal mode, but on most keyboards the <kbd>Esc</kbd> key is pretty far from the home row. <kbd>Ctrl-\[</kbd> produces the same keycode but involves two hands. Both might have problems on latent terminals which support <kbd>Esc</kbd> as an alternative to <kbd>Meta</kbd>. <kbd>Ctrl-C</kbd> is the answer — it's easy to type and instant. The only caveat is that you still need to use <kbd>Esc</kbd> for operations in visual block mode.

Moving around text is part of what makes using Vim feel so efficient. The one single thing I could never stand about Vim's default movements, however, is how <kbd>j</kbd> and <kbd>k</kbd> move around wrapped lines. By default they move you one line down and up, respectively, but on a _linewise_ basis. If I hit <kbd>j</kbd> I expect the cursor to move down a single row on the screen, just like every other text editing area in the world. The following does just that:

    :nmap j gj
    :nmap k gk

It might be amusing to refer to Vim's command line as such when by default it behaves very unlike a modern command line. If you're used to Emacs-style movement keys on your Bash or Zsh command line you might want to make Vim act the same way:

    :cnoremap <C-a>  <Home>
    :cnoremap <C-b>  <Left>
    :cnoremap <C-f>  <Right>
    :cnoremap <C-d>  <Delete>
    :cnoremap <M-b>  <S-Left>
    :cnoremap <M-f>  <S-Right>
    :cnoremap <M-d>  <S-right><Delete>
    :cnoremap <Esc>b <S-Left>
    :cnoremap <Esc>f <S-Right>
    :cnoremap <Esc>d <S-right><Delete>
    :cnoremap <C-g>  <C-c>

Another thing we do often is search, so it makes sense to have some sane defaults. The `incsearch` option highlights as you type an expression (a.k.a. "Emacs style"), and `ignorecase` plus `smartcase` make searches case-insensitive _except_ when you include upper-case characters (so `/foo` matches `FOO` and `fOo`, but `/FOO` only matches the former). `hlsearch` is a useful option which highlights the current search, but the highlight can become annoying so it makes sense to have a key to clear the highlight when you no longer need it:

    :set incsearch
    :set ignorecase
    :set smartcase
    :set hlsearch
    :nmap \q :nohlsearch<CR>

## Vim, the Terminal, Buffers, and You.

There are two forms: Vim in the console and the native GVim application. The advantages of GVim are better OS integration for dialogs, printing and the clipboard as well as prettier theme colors.

It was decided early in its development that [Vim isn't designed to replace a terminal][vimnoterm], so Vim is and forever will be bad at emulating terminals. Trying to use `:shell` is a path to madness. One plugin, [Conque][conque], comes close to terminal support in Vim, but it caused Vim to hang and its integration felt clunky. Thus, if you do a lot of work with from the command line while you edit, the best way to run Vim is from the command line.

One of Vim's strengths is that it starts lightning fast, so starting Vim from the terminal is trivial. With a modern, 256-color terminal like [iTerm][iterm] or Gnome Terminal, it will even look like GVim. But the best part is that you can drop into the command line at any time with <kbd>Ctrl-Z</kbd>, which suspends Vim, and your working directory is where you left off.

If you have trouble remembering which terminal has Vim suspended, try [adding the number of background jobs to your shell prompt][bashstoppedjobs]. If you have many Vims in the background, however, you should start using buffers instead.

Vim has the powerful ability to keep multiple files open in the background, and there are many ways to navigate between them. This is useful for performing work on a project or for editing multiple files as part of an operation.

For example, say your current working directory is a Django project and you want to edit the shopping cart request handler, so you run `vim cart/views.py`. Once Vim is open you realize you need to change a setting so you type `:e settings.py`, which opens up the file `settings.py` in the current window. You can get back to the other file by running `:b views` (`:b` is short for `:buffer`), which performs a substring match across all buffers, or use `:b#`, which opens the previously viewed buffer. Buffers become more powerful once you start using CtrlP, which I'll get to below.

A lot of times you'll want to do some work somewhere other than the file you're editing and return afterward, in which case `:b#` is a godsend. (Or `:e#`, I'm not sure if there's a difference.) It's so useful that it deserves a more natural keybinding, like <kbd>Ctrl-E</kbd>. (The default binding is <kbd>Ctrl-Shift-6</kbd>, which you'll never remember, and nobody knows what <kbd>Ctrl-E</kbd> does anyway.)

    :nmap <C-e> :e#<CR>

Vim automatically creates a buffer for each file on the command line. This is useful from the command line, such as with `vim *.js`, or combined with grep/[ack][ack]: ``vim `grep -l foo *.js` ``. I use this pattern so often that I bound two keys to cycle between all open buffers:

    :nmap <C-n> :bnext<CR>
    :nmap <C-p> :bprev<CR>

## Yes, My Editor Does That

TextMate raised the bar when it introduced it's "Go To File..." command which lets you quickly jump to any file using a fuzzy text search. The best Vim equivalent is [Ctrl-P][ctrlp], which not only has a fuzzy file search, but a fuzzy buffer search as well:

XXXX pic of ctrlp

If you use Vim buffers, Ctrl-P's ability to quickly go to the buffer you want is life-changing. It's so useful that I've bound it to <kbd>;</kbd> (and nobody remembers what <kbd>;</kbd> does anyway). Ctrl-P's file search combined with buffer search is magnificent – use the file search to open files related to the task at hand, then use buffer search to flip in between them.

    :nmap ; :CtrlPBuffer<CR>

It's worth showing a few settings for Ctrl-P. The following are the settings I use which map it to <kbd>,t</kbd>, put it at the top of the screen, hide unnecessary files from the search results, and a few more things. Run `:help ctrlp-options` to read more about them.

    :let g:ctrlp_map = '<Leader>t'
    :let g:ctrlp_match_window_bottom = 0
    :let g:ctrlp_match_window_reversed = 0
    :let g:ctrlp_custom_ignore = '\v\~$|\.(o|swp|pyc|wav|mp3|ogg|blend)$|(^|[/\\])\.(hg|git|bzr)($|[/\\])|__init__\.py'
    :let g:ctrlp_working_path_mode = 0
    :let g:ctrlp_dotfiles = 0
    :let g:ctrlp_switch_buffer = 0

A collapsible directory tree is a great tool to explore a project structure when you don't know what you're looking for or to help keep the project's organization in your head. The best file browser plugin is [NERD Tree][nerdtree], which has easy-to-remember keyboard navigation (hit <kbd>?</kbd> in the window for help), mouse support, and uses little Unicode arrows next to folders.

(XXXX pic of nerd tree)


    :nmap \e :NERDTreeToggle<CR>

Syntastic for 

256 color support and pretty themes

## Dealing With Other People's Code

\t \T \m \M for tabs

\w for width

\u for lists

## Things Which Friends Found Interesting

Registers (vs buffer ring)

Block select - insert and delete

Overwrite

delete-in-tag

ack and vack

# Conclusion

my vim config is [here][vimrc]

## Appendix A: Things I Miss From Emacs

* CSS highlighting everywhere.
* Decent search and replace.
* Multiple font sizes.

## Appendix B: Things I Miss From Intelli-J, Eclipse, and Flash Builder

* Refactoring
* Smart completion (tried rope, it's awful)
* Arbitrary highlights

  [bashstoppedjobs]: http://tldp.yolinux.com/HOWTO/Bash-Prompt-HOWTO.html#AEN733
